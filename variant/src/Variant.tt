<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ include file="Functions.ttinclude" #>
<#@ parameter type="System.Int32" name="VariantArgumentTypesCount" #>
// Copyright 2022-<#= DateTime.Now.Year #> variant Project
// Licensed under Apache License 2.0 or any later version
// Refer to the LICENSE file included.

namespace System;

<#
    for (var variant = 1; variant < VariantArgumentTypesCount; variant++) {
        var variantTypeParameters = Enumerable.Range(0, variant + 1).Select(VariantTypeParameter).ToArray();
        var variantType = VariantType(variantTypeParameters);
        var seeVariantType = SeeVariantType(variantTypeParameters);
#>
/// <summary>
/// A type-safe union containing one of its <#= variantTypeParameters.Length #> type arguments at a time
/// </summary>
<#
        for (var i = 0; i < variantTypeParameters.Length; i++) {
            var variantTypeParameter = variantTypeParameters[i];
#>
/// <typeparam name="<#= variantTypeParameter #>"><#= Nth(i + 1) #> possible value type</typeparam>
<#
        }
#>
/// <remarks>Generated by T4 tool</remarks>
public sealed class <#= variantType #> : IEquatable<<#= variantType #>> {

<#
        for (int constant = 0; constant <= variant; constant++) {
#>
    private const byte _t<#= constant #>Index = <#= constant #>;
<#
        }
#>

    private readonly byte _index;
    private readonly object _value;

<#
        for (var constructor = 0; constructor <= variant; constructor++) {
            var variantTypeParameter = variantTypeParameters[constructor];
            var paramName = $"t{constructor}";
#>
    /// <summary>
    /// Create an instance of <#= seeVariantType #> containing a <typeparamref name="<#= variantTypeParameter #>"/>
    /// </summary>
    /// <param name="<#= paramName #>"><typeparamref name="<#= variantTypeParameter #>"/> instance</param>
    public Variant(<#= variantTypeParameter #> <#= paramName #>) {
        // _value can contain null only if <#= variantTypeParameter #> is nullable
        _value = <#= paramName #>!;
        _index = _t<#= constructor #>Index;
    }

<#
        }
#>
    /// <summary>
    /// Map the value held by this variant using the suitable function
    /// </summary>
<#
        foreach (var variantTypeParameter in variantTypeParameters) {
#>
    /// <param name="map<#= variantTypeParameter #>">Function taking a <typeparamref name="<#= variantTypeParameter #>"/> and returning a <typeparamref name="T"/></param>
<#
        }
#>
    /// <typeparam name="T">Result type</typeparam>
    /// <returns>Mapping result</returns>
    public T Map<T>(<#=
            string.Join(",\n                    ", variantTypeParameters.Select(t => $"Func<{t}, T> map{t.ToUpper()}")) #>) {
        // A switch statement is faster than a switch expression
#pragma warning disable IDE0066
        switch (_index) {
<#
        for (var @case = 0; @case <= variant; @case++) {
            var variantTypeParameter = VariantTypeParameter(@case);
#>
            case _t<#= @case #>Index:
                return map<#= variantTypeParameter #>((<#= variantTypeParameter #>) _value);
<#
        }
#>
            default:
                throw new InvalidOperationException("Variant doesn't contain a value");
        }
#pragma warning restore IDE0066
    }

    /// <summary>
    /// Call the suitable action based on the value held by this variant
    /// </summary>
<#
        foreach (var variantTypeParameter in variantTypeParameters) {
#>
    /// <param name="case<#= variantTypeParameter #>">Action taking a <typeparamref name="<#= variantTypeParameter #>"/> </param>
<#
        }
#>
    public void Switch(<#=
            string.Join(",\n                       ", variantTypeParameters.Select(t => $"Action<{t}> case{t.ToUpper()}")) #>) {
        switch (_index) {
<#
        for (var @case = 0; @case <= variant; @case++) {
            var variantTypeParameter = VariantTypeParameter(@case);
#>
            case _t<#= @case #>Index:
                case<#= variantTypeParameter #>((<#= variantTypeParameter #>) _value);
                break;
<#
        }
#>
            default:
                throw new InvalidOperationException("Variant doesn't contain a value");
        }
    }

    /// <summary>
    /// Indicates whether the current object is equal to another object of the same type.
    /// </summary>
    /// <param name="other">An object to compare with this object.</param>
    /// <returns><c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.</returns>
    public bool Equals(<#= variantType #>? other) {
        // Null
        if (other is null) {
            return false;
        }

        // Reference
        if (ReferenceEquals(this, other)) {
            return true;
        }

        // Content
        return _index == other._index && Equals(_value, other._value);
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current object.
    /// </summary>
    /// <param name="obj">The object to compare with the current object.</param>
    /// <returns><c>true</c> if the specified object is equal to the current object; otherwise, <c>false</c>.</returns>
    public override bool Equals(object? obj) => Equals(obj as <#= variantType #>);

    /// <summary>
    /// Compute the hash code for the current object
    /// </summary>
    /// <returns>A hash code for the current object</returns>
    public override int GetHashCode() => HashCode.Combine(_index, _value);

    /// <summary>Test whether the values of two <#= seeVariantType #> objects are equal</summary>
    /// <param name="left">The first value to compare</param>
    /// <param name="right">The second value to compare</param>
    /// <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false</returns>
    public static bool operator ==(<#= variantType #>? left, <#= variantType #>? right) => Equals(left, right);

    /// <summary>Test whether two <#= seeVariantType #> objects have different values</summary>
    /// <param name="left">The first value to compare</param>
    /// <param name="right">The second value to compare</param>
    /// <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false</returns>
    public static bool operator !=(<#= variantType #>? left, <#= variantType #>? right) => !(left == right);
<#
        // Implicit operators
        for (var @operator = 0; @operator <= variant; @operator++) {
            var argName = $"t{@operator}";
            var argType = variantTypeParameters[@operator];
#>

    /// <summary>
    /// Convert a <typeparamref name="<#= argType #>"/> into a <#= seeVariantType #>
    /// </summary>
    /// <param name="<#= argName #>">Conversion input</param>
    /// <returns>Variant</returns>
    public static implicit operator <#= variantType #>(<#= argType #> <#= argName #>) =>
        new(<#= argName #>);
<#
        }
        if (variantTypeParameters.Length > 1) {
            foreach (var variantSubsetTypeParameters in SubLists(variantTypeParameters).Select(a => a.ToArray())) {
#>

    /// <summary>
    /// Convert a <#= SeeVariantType(variantSubsetTypeParameters) #> into a <#= seeVariantType #>
    /// </summary>
    /// <param name="variant">Conversion input</param>
    /// <returns>Variant</returns>
    public static implicit operator <#= variantType #>(<#= VariantType(variantSubsetTypeParameters) #> variant) =>
        variant.Map<<#= variantType #>>(<#=
                    string.Join(", ", variantSubsetTypeParameters.Select(_ => "t => t")) #>);
<#
            }
        }
#>
}<#
        if (variant != VariantArgumentTypesCount - 1) {
#>


<#
        }
    }

    string Nth(int number) => number switch {
        1 => "1st",
        2 => "2nd",
        3 => "3rd",
        _ => $"{number}th"
        };
#>
